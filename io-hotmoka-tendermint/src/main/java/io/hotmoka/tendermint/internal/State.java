package io.hotmoka.tendermint.internal;

import io.hotmoka.beans.references.TransactionReference;
import io.hotmoka.beans.responses.TransactionResponseWithInstrumentedJar;
import jetbrains.exodus.ArrayByteIterable;
import jetbrains.exodus.ByteIterable;
import jetbrains.exodus.env.Environment;
import jetbrains.exodus.env.Environments;
import jetbrains.exodus.env.Store;
import jetbrains.exodus.env.StoreConfig;
import jetbrains.exodus.env.Transaction;

/**
 * The state of the blockchain. It is a transactional database that keeps
 * information about the state of the objects created by the transactions executed
 * by the blockchain. Such information is not kept in blockchain, but only
 * its hash is stored in blockchain at the end of each block, for consensus.
 */
class State implements AutoCloseable {
	private final Environment env;
    private Transaction txn;
    private Store responses;

    /**
     * The name of the store where responses of transactions are kept.
     */
    private final static String RESPONSES = "responses";

    State() {
    	this.env = Environments.newInstance("tmp/storage");
    }

    @Override
	public void close() {
    	env.close();
	}

    /**
     * Starts a transaction. All updates during the transaction are saved
     * if the transaction will later be committed. This is called at the beginning
     * of the execution of the transactions inside a block.
     */
	void beginTransaction() {
		txn = env.beginTransaction();
        responses = env.openStore(RESPONSES, StoreConfig.WITHOUT_DUPLICATES, txn);
	}

	/**
	 * Commits all updates during the current transaction.
	 */
	void commitTransaction() {
		txn.commit();
	}

	/**
	 * Keeps in the state the result of installing a jar in blockchain.
	 * 
	 * @param transactionReference the reference of the transaction that installed the jar in blockchain
	 * @param response the response of the jar installation request
	 */
	void keepJar(TransactionReference transactionReference, TransactionResponseWithInstrumentedJar response) {
		responses.put(txn, new ArrayByteIterable(transactionReference.toString().getBytes()), new ArrayByteIterable(response.getInstrumentedJar()));
	}

	/**
	 * Yields the instrumented jar that was generated by the jar store transaction with the given reference.
	 * 
	 * @param transactionReference the reference to the transaction
	 * @return the instrumented jar, as its sequence of bytes
	 * @throws IllegalArgumentException if the jar could not be found, for instance because the referenced transaction didn't install a jar in blockchain
	 */
	byte[] getInstrumentedJarAt(TransactionReference transactionReference) {
		return env.computeInReadonlyTransaction(txn -> {
			Store responses = env.openStore(RESPONSES, StoreConfig.WITHOUT_DUPLICATES, txn);
			ByteIterable jar = responses.get(txn, new ArrayByteIterable(transactionReference.toString().getBytes()));
			if (jar == null)
				throw new IllegalArgumentException("the transaction does not contain a jar store response");

			return jar.getBytesUnsafe();
		});
	}
}