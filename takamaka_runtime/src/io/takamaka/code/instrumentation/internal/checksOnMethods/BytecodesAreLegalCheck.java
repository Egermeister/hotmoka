package io.takamaka.code.instrumentation.internal.checksOnMethods;

import org.apache.bcel.Const;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.JsrInstruction;
import org.apache.bcel.generic.MONITORENTER;
import org.apache.bcel.generic.MONITOREXIT;
import org.apache.bcel.generic.PUTSTATIC;
import org.apache.bcel.generic.RET;
import org.apache.bcel.generic.StoreInstruction;

import io.takamaka.code.instrumentation.internal.VerifiedClass;
import io.takamaka.code.instrumentation.issues.IllegalJsrInstructionError;
import io.takamaka.code.instrumentation.issues.IllegalPutstaticInstructionError;
import io.takamaka.code.instrumentation.issues.IllegalRetInstructionError;
import io.takamaka.code.instrumentation.issues.IllegalSynchronizationError;
import io.takamaka.code.instrumentation.issues.IllegalUpdateOfLocal0Error;

/**
 * A check that the method has no unusual bytecodes, such as {@code jsr}, {@code ret}
 * or updates of local 0 in instance methods. Such bytecodes are allowed in
 * Java bytecode, although they are never generated by modern compilers. Takamaka forbids them
 * since they make code verification more difficult.
 */
public class BytecodesAreLegalCheck extends VerifiedClass.ClassVerification.MethodVerification.Check {

	public BytecodesAreLegalCheck(VerifiedClass.ClassVerification.MethodVerification verification) {
		verification.super();

		instructions().forEach(this::checkIfItIsIllegal);
	}

	private void checkIfItIsIllegal(InstructionHandle ih) {
		Instruction ins = ih.getInstruction();

		if (ins instanceof PUTSTATIC) {
			// static field updates are allowed inside the synthetic methods or static initializer,
			// for instance in an enumeration
			if (!method.isSynthetic() && !Const.STATIC_INITIALIZER_NAME.equals(methodName))
				issue(new IllegalPutstaticInstructionError(clazz, methodName, lineOf(ih)));
		}
		else if (ins instanceof JsrInstruction)
			issue(new IllegalJsrInstructionError(clazz, methodName, lineOf(ih)));
		else if (ins instanceof RET)
			issue(new IllegalRetInstructionError(clazz, methodName, lineOf(ih)));
		else if (!method.isStatic() && ins instanceof StoreInstruction && ((StoreInstruction) ins).getIndex() == 0)
			issue(new IllegalUpdateOfLocal0Error(clazz, methodName, lineOf(ih)));					
		else if (ins instanceof MONITORENTER || ins instanceof MONITOREXIT)
			issue(new IllegalSynchronizationError(clazz, methodName, lineOf(ih)));
	}
}