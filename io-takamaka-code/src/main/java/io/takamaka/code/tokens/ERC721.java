package io.takamaka.code.tokens;

/*
Copyright 2021 Filippo Fantinato and Fausto Spoto

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import static io.takamaka.code.lang.Takamaka.require;

import java.util.function.Supplier;

import io.takamaka.code.lang.Contract;
import io.takamaka.code.lang.Event;
import io.takamaka.code.lang.Exported;
import io.takamaka.code.lang.ExternallyOwnedAccount;
import io.takamaka.code.lang.FromContract;
import io.takamaka.code.lang.Storage;
import io.takamaka.code.lang.Takamaka;
import io.takamaka.code.lang.View;
import io.takamaka.code.math.UnsignedBigInteger;
import io.takamaka.code.util.StorageMap;
import io.takamaka.code.util.StorageMapView;
import io.takamaka.code.util.StorageSet;
import io.takamaka.code.util.StorageTreeMap;
import io.takamaka.code.util.StorageTreeSet;

/**
 * Implementation of the ERC721 standard for non-fungible tokens.
 * This code has been inspired by OpenZeppelin's implementation in Solidity:
 * <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol>[ERC721.sol]</a>.
 */
public class ERC721 extends Contract implements IERC721 {

	/**
	 * The name of the token collection.
	 */
	private final String name;

	/**
	 * The symbol of the token collection.
	 */
	private final String symbol;

	/**
	 * True if and only if events get generated by this token collection.
	 */
	private final boolean generateEvents;

	protected final UnsignedBigInteger ZERO = UnsignedBigInteger.valueOf(0);
	protected final UnsignedBigInteger ONE = UnsignedBigInteger.valueOf(1);

	/**
	 * A map from each token identifier to its owner.
	 */
	private final StorageMap<UnsignedBigInteger, Contract> owners = new StorageTreeMap<>();

	/**
	 * A map from each owner to the number of tokens that it owns.
	 */
	private final StorageMap<Contract, UnsignedBigInteger> balances = new StorageTreeMap<>();

	/**
	 * A map from each token identifier to a contract that has been approved
	 * for transferring the token: only that contract and the owner of the token
	 * can transfer the token.
	 */
	private final StorageMap<UnsignedBigInteger, Contract> tokenApprovals = new StorageTreeMap<>();

	/**
	 * A map from each owner to the set of contracts that it has approved for
	 * transferring all its tokens.
	 */
	private final StorageMap<Contract, StorageSet<Contract>> operatorApprovals = new StorageTreeMap<>();

	/**
	 * Builds a collection of non-fungible tokens that does not generate events.
	 * 
	 * @param name the name of the collection
	 * @param symbol the symbol of the collection
	 */
	public ERC721(String name, String symbol) {
		this(name, symbol, false);
	}

	/**
	 * Builds a collection of non-fungible tokens.
	 * 
	 * @param name the name of the collection
	 * @param symbol the symbol of the collection
	 * @param generateEvents true if and only if the collection generates events
	 */
	public ERC721(String name, String symbol, boolean generateEvents) {
		this.name = name;
		this.symbol = symbol;
		this.generateEvents = generateEvents;
	}

	/**
	 * Yields the token collection name.
	 */
	@View
	public final String name() {
		return name;
	}

	/**
	 * Yields the token collection symbol.
	 */
	@View
	public final String symbol() {
		return symbol;
	}

	@Override @FromContract
	public void transferFrom(Contract from, Contract to, UnsignedBigInteger tokenId) {
		require(_isApprovedOrOwner(caller(), tokenId), "transfer caller is not owner nor approved");
		require(to instanceof ExternallyOwnedAccount || to instanceof IERC721Receiver,
			"transfer destination must be an externally owned account or implement IERC721Receiver");
		_transfer(from, to, tokenId);
	}

	/**
	 * Called before a token gets transferred. Subclasses might add specific code here.
	 * 
	 * @param from the previous owner of the token
	 * @param to the new owner of the token
	 * @param tokenId the identifier of the token
	 */
	protected void _beforeTokenTransfer(Contract from, Contract to, UnsignedBigInteger tokenId) { }

	protected void _transfer(Contract from, Contract to, UnsignedBigInteger tokenId) {
		require(ownerOf(tokenId).equals(from), "transfer of token that is not own");
		require(to != null, "transfer to {@code null}");

		_beforeTokenTransfer(from, to, tokenId);
		clearApproval(tokenId);
		balances.put(from, balanceOf(from).subtract(ONE));
		balances.put(to, balanceOf(to).add(ONE));
		owners.put(tokenId, to);
		event(new Transfer(from, to, tokenId));
	}

	@Override @FromContract
	public void approve(Contract to, UnsignedBigInteger tokenId) {
		Contract owner = ownerOf(tokenId);
		Contract caller = caller();
		require(owner != to, "approval to current owner");
		require(caller == owner || isApprovedForAll(owner, caller), "the caller is not owner nor approved for all");

		tokenApprovals.put(tokenId, to);
		event(new Approval(ownerOf(tokenId), to, tokenId));
	}

	private void clearApproval(UnsignedBigInteger tokenId) {
		tokenApprovals.remove(tokenId);
		event(new Approval(ownerOf(tokenId), null, tokenId));
	}

	@Override @FromContract
	public void setApprovalForAll(Contract operator, boolean _approved) {
		Contract caller = caller();
		require(operator != caller, "the caller cannot approve itself");

		StorageSet<Contract> spenders = operatorApprovals.computeIfAbsent(caller, (Supplier<StorageTreeSet<Contract>>) StorageTreeSet::new);
		if (_approved)
			spenders.add(operator);
		else
			spenders.remove(operator);

		event(new ApprovalForAll(caller, operator, _approved));
	}

	@Override @View
	public Contract getApproved(UnsignedBigInteger tokenId) {
		require(_exists(tokenId), "approved query for non-existent token");
		return tokenApprovals.get(tokenId);
	}

	@Override @View
	public final boolean isApprovedForAll(Contract owner, Contract operator) {
		StorageSet<Contract> spenders = operatorApprovals.get(owner);
		return spenders != null && spenders.contains(operator);
	}

	/**
	 * Determines if {@code spender} can transfer the given token, since it is
	 * its owner or has been approved by its owner.
	 * 
	 * @param spender the contract that should transfer the token
	 * @param tokenId the identifier of the token
	 * @return true if and only if that condition holds
	 */
	protected boolean _isApprovedOrOwner(Contract spender, UnsignedBigInteger tokenId) {
		require(_exists(tokenId), "query for non-existent token");
		Contract owner = ownerOf(tokenId);

		return spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender);
	}

	/**
	 * Mints a new token.
	 * 
	 * @param to the owner of the new token. This must be an externally owned account
	 *        or implement {@link IERC721Receiver}
	 * @param tokenId the identifier of the new token
	 */
	protected void _mint(Contract to, UnsignedBigInteger tokenId) {
		require(!_exists(tokenId), "token already minted");
		require(to instanceof ExternallyOwnedAccount || to instanceof IERC721Receiver,
			"mint destination must be an externally owned account or implement IERC721Receiver");

		_beforeTokenTransfer(null, to, tokenId);
		balances.put(to, balanceOf(to).add(ONE));
		owners.put(tokenId, to);
		event(new Transfer(null, to, tokenId));
	}

	/**
	 * Returns the Uniform Resource Identifier (URI) for token {@code tokenId}.
	 */
	@View
	public String tokenURI(UnsignedBigInteger tokenId) {
		require(_exists(tokenId), "URI query for non-existent token");

		String baseURI = _baseURI();
		return !baseURI.isEmpty() ? baseURI + tokenId : "";
	}

	/**
	 * Yields the base form the URI for the tokens of this contract.
	 * Subclasses can specify their base URI here.
	 * 
	 * @return the base form of the URI
	 */
	@View
	protected String _baseURI() {
		return "";
	}

	@Override @View
	public UnsignedBigInteger balanceOf(Contract owner) {
		require(owner != null, "balance query for null");

		return balances.getOrDefault(owner, ZERO);
	}

	@Override @View
	public Contract ownerOf(UnsignedBigInteger tokenId) {
		Contract owner = owners.get(tokenId);
		require(owner != null, "non-existent token");

		return owner;
	}

	@Override @View
	public IERC721View snapshot() {

		@Exported
		class ERC721Snapshot extends Storage implements IERC721View {
			private final StorageMapView<UnsignedBigInteger, Contract> owners = ERC721.this.owners.snapshot();
			private final StorageMapView<Contract, UnsignedBigInteger> balances = ERC721.this.balances.snapshot();

			@Override @View
			public UnsignedBigInteger balanceOf(Contract owner) {
				return balances.getOrDefault(owner, ZERO);
			}

			@Override @View
			public Contract ownerOf(UnsignedBigInteger tokenId) {
				Contract owner = owners.get(tokenId);
				require(owner != null, "owner query for non-existent token");

				return owner;
			}

			@Override @View
			public IERC721View snapshot() {
				return this;
			}
		}

		return new ERC721Snapshot();
	}

	/**
	 * Burns a token.
	 * 
	 * @param tokenId the identifier of the token to burn. This must already exist
	 */
	protected void _burn(UnsignedBigInteger tokenId) {
		Contract owner = ownerOf(tokenId);
		_beforeTokenTransfer(owner, null, tokenId);
		clearApproval(tokenId);

		balances.put(owner, balanceOf(owner).subtract(ONE));
		owners.remove(tokenId);

		event(new Transfer(owner, null, tokenId));
	}

	@View
	protected final boolean _exists(UnsignedBigInteger tokenId) {
		return owners.containsKey(tokenId);
	}

	/**
	 * Generates the given event if events are allowed for this token.
	 *
	 * @param event the event to generate
	 */
	protected final void event(Event event) {
		if (generateEvents)
			Takamaka.event(event);
	}
}